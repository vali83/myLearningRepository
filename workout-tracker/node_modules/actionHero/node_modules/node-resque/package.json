{
  "author": {
    "name": "Evan Tahler",
    "email": "evantahler@gmail.com"
  },
  "name": "node-resque",
  "description": "an opinionated implementation of resque in node",
  "version": "0.2.5",
  "homepage": "http://github.com/taskrabbit/node-resque",
  "repository": {
    "type": "git",
    "url": "git://github.com/taskrabbit/node-resque.git"
  },
  "main": "index.js",
  "keywords": [
    "delayed",
    "queue",
    "resque",
    "redis"
  ],
  "engines": {
    "node": ">=0.8.0"
  },
  "dependencies": {
    "redis": "0.8.x"
  },
  "devDependencies": {
    "mocha": "1.9.x",
    "should": "1.2.x"
  },
  "scripts": {
    "test": "./node_modules/.bin/mocha --reporter spec"
  },
  "readme": "# node-resque\nDelayed Tasks in nodejs.  A very opinionated but compatible API with [resque](https://github.com/resque/resque) and [resque scheduler](https://github.com/resque/resque-scheduler)\n\n[![Nodei stats](https://nodei.co/npm/node-resque.png?downloads=true)](https://npmjs.org/package/node-resque)\n\n[![Build Status](https://secure.travis-ci.org/taskrabbit/node-resque.png?branch=master)](http://travis-ci.org/taskrabbit/node-resque)\n\n## Usage\n\nI learn best by examples:\n\n```javascript\n/////////////////////////\n// REQUIRE THE PACKAGE //\n/////////////////////////\n\nvar NR = require(\"node-resque\");\n\n///////////////////////////\n// SET UP THE CONNECTION //\n///////////////////////////\n\nvar connectionDetails = {\n  host:      \"127.0.0.1\",\n  password:  \"\",\n  port:      6379,\n  database:  0,\n}\n\n//////////////////////////////\n// DEFINE YOUR WORKER TASKS //\n//////////////////////////////\n\nvar jobs = {\n  \"add\": {\n    perform: function(a,b,callback){\n      var answer = a + b;\n      callback(answer);\n    },\n  },\n  \"subtract\": {\n    perform: function(a,b,callback){\n      var answer = a - b;\n      callback(answer);\n    },\n  },\n};\n\n////////////////////\n// START A WORKER //\n////////////////////\n\nvar worker = new NR.worker({connection: connectionDetails, queues: ['math']}, jobs, function(){\n  worker.workerCleanup(); // optional: cleanup any previous improperly shutdown workers\n  worker.start();\n});\n\n///////////////////////\n// START A SCHEDULER //\n///////////////////////\n\nvar scheduler = new NR.scheduler({connection: connectionDetails}, function(){\n  scheduler.start();\n});\n\n/////////////////////////\n// REGESTER FOR EVENTS //\n/////////////////////////\n\nworker.on('start',           function(){ console.log(\"worker started\"); })\nworker.on('end',             function(){ console.log(\"worker ended\"); })\nworker.on('cleaning_worker', function(worker, pid){ console.log(\"cleaning old worker \" + worker); })\nworker.on('poll',            function(queue){ console.log(\"worker polling \" + queue); })\nworker.on('job',             function(queue, job){ console.log(\"working job \" + queue + \" \" + JSON.stringify(job)); })\nworker.on('reEnqueue',       function(queue, job, plugin){ console.log(\"reEnqueue job (\" + plugin + \") \" + queue + \" \" + JSON.stringify(job)); })\nworker.on('success',         function(queue, job, result){ console.log(\"job success \" + queue + \" \" + JSON.stringify(job) + \" >> \" + result); })\nworker.on('error',           function(queue, job, error){ console.log(\"job failed \" + queue + \" \" + JSON.stringify(job) + \" >> \" + error); })\nworker.on('pause',           function(){ console.log(\"worker paused\"); })\n\nscheduler.on('start',             function(){ console.log(\"scheduler started\"); })\nscheduler.on('end',               function(){ console.log(\"scheduler ended\"); })\nscheduler.on('poll',              function(){ console.log(\"scheduler polling\"); })\nscheduler.on('working_timestamp', function(timestamp){ console.log(\"scheduler working timestamp \" + timestamp); })\nscheduler.on('transferred_job',    function(timestamp, job){ console.log(\"scheduler enquing job \" + timestamp + \" >> \" + JSON.stringify(job)); })\n\n////////////////////////\n// CONNECT TO A QUEUE //\n////////////////////////\n\nvar queue = new NR.queue({connection: connectionDetails}, jobs, function(){\n  queue.enqueue('math', \"add\", [1,2]);\n  queue.enqueue('math', \"add\", [2,3]);\n  queue.enqueueIn(3000, 'math', \"subtract\", [2,1]);\n});\n```\n\n## Configutation Options:\n\n`new queue` requires only the \"queue\" variable to be set.  You can also pass the `jobs` hash to it.\n\n`new worker` has some additonal options:\n\n```javascript\noptions = {\n  looping: true,\n  timeout: 5000,\n  queues:  \"*\",\n  name:    os.hostname() + \":\" + process.pid\n}\n```\n\nThe configuration hash passed to `new worker`, `new scheduler` or `new queue` can also take a `connection` option.\n\n```javascript\nvar connectionDetails = {\n  host:      \"127.0.0.1\",\n  password:  \"\",\n  port:      6379,\n  database:  0,\n  namespace: \"resque\",\n}\n\nvar worker = new NR.worker({connection: connectionDetails, queues: 'math'}, jobs, function(){\n  worker.start();\n});\n```\n\n## Notes\n- Be sure to call `worker.end()` before shutting down your application if you want to properly clear your worker status from resque\n- When ending your application, be sure to allow your workers time to finsih what they are working on\n- `worker.workerCleanup()` only works for *nix operating systems (osx, unix, solaris, etc)\n- If you are using any plugins which effect `beforeEnqueue` or `afterEnqueue`, be sure to pass the `jobs` argument to the `new Queue` constructor\n- If you plan to run more than one worker per nodejs process, be sure to name them something distinct.  Names **must** follow the patern `hostname:pid+unique_id`.  For example:\n\n```javascript\nvar name = os.hostname() + \":\" + process.pid() + \"+\" + counter;\nvar worker = new NR.worker({connection: connectionDetails, queues: 'math', 'name' : name}, jobs);\n```\n## Queue Managment\n\nAdditonal methods provided on the `queue` object:\n\n- **queue.prototype.queues** = function(callback)\n  - callback(error, array_of_queues)\n- **queue.prototype.length** = function(q, callback)\n  - callback(error, number_of_elements_in_queue)\n- **queue.prototype.del** = function(q, func, args, count, callback)\n  - callback(error, number_of_items_deleted)\n- **queue.prototype.delDelayed** = function(q, func, args, callback)\n  - callback(error, timestamps_the_job_was_removed_from)\n- **queue.prototype.scheduledAt** = function(q, func, args, callback)\n  - callback(error, timestamps_the_job_is_scheduled_for)\n\n## Plugins\n\nJust like ruby's resque, you can write worker plugins.  They look look like this.  The 4 hooks you have are `before_enqueue`, `after_enqueue`, `before_perform`, and `after_perform`\n\n```javascript\n\nvar myPlugin = function(worker, func, queue, job, args, options){\n  var self = this;\n  self.worker = worker;\n  self.queue = queue;\n  self.func = func;\n  self.job = job;\n  self.args = args;\n  self.options = options;\n}\n\n////////////////////\n// PLUGIN METHODS //\n////////////////////\n\nmyPlugin.prototype.before_enqueue = function(callback){\n  // console.log(\"** before_enqueue\")\n  callback(null, true);\n}\n\nmyPlugin.prototype.after_enqueue = function(callback){\n  // console.log(\"** after_enqueue\")\n  callback(null, true);\n}\n\nmyPlugin.prototype.before_perform = function(callback){\n  // console.log(\"** before_perform\")\n  callback(null, true);\n}\n\nmyPlugin.prototype.after_perform = function(callback){\n  // console.log(\"** after_perform\")\n  callback(null, true);\n}\n\n```\n\nAnd then your plugin can be invoked within a job like this:\n\n```javascript\nvar jobs = {\n  \"add\": {\n    plugins: [ 'myPlugin' ],\n    pluginOptions: {\n      myPlugin: { thing: 'stuff' },\n    },\n    perform: function(a,b,callback){\n      var answer = a + b;\n      callback(answer);\n    },\n  },\n}\n```\n\n**notes**\n\n- All plugins which return `(error, toRun)`.  if `toRun = false` on  `beforeEnqueue`, the job beign inqueued will be thrown away, and if `toRun = false` on `beforePerfporm`, the job will be reEnqued and not run at this time.  However, it doesn't really matter what `toRun` returns on the `after` hooks.\n\n- There are a few included plugins, all in the lib/plugins/* directory. You can rewrite you own and include it like this:\n\n```javascript\nvar jobs = {\n  \"add\": {\n    plugins: [ require('myplugin') ],\n    pluginOptions: {\n      myPlugin: { thing: 'stuff' },\n    },\n    perform: function(a,b,callback){\n      var answer = a + b;\n      callback(answer);\n    },\n  },\n}\n```\n\n\n\n## Acknowledgments\nMost of this code was inspired by / stolen from [coffee-resque](https://npmjs.org/package/coffee-resque) and [coffee-resque-scheduler](https://github.com/leeadkins/coffee-resque-scheduler).  Thanks!\n",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/taskrabbit/node-resque/issues"
  },
  "_id": "node-resque@0.2.5",
  "dist": {
    "shasum": "df0fc0be8a5ddafbde15e1c6cfe08649a8800963"
  },
  "_from": "node-resque@~0.2.4",
  "_resolved": "https://registry.npmjs.org/node-resque/-/node-resque-0.2.5.tgz"
}
